// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-11-03T03:51:54Z

package model

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"strings"

	"example.com/app-api/util"
	"example.com/app-api/util/jsql"
)

func (r *UserStoreImpl) Update(ctx context.Context, obj User, fields []UserField) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	obj.Email = strings.ToLower(obj.Email)
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	defer tx.Rollback()
	args := []any{}
	qry := `UPDATE app_user SET`
	if len(args) > 0 {
		qry += ","
	}
	args = append(args, obj.Version+1)
	qry += fmt.Sprintf("  version = $%d", len(args))
	for _, f := range fields {
		switch f {
		case UserField_Email:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Email)
			qry += fmt.Sprintf("  email = $%d", len(args))
		case UserField_Name:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Name)
			qry += fmt.Sprintf("  name = $%d", len(args))
		case UserField_Token:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Token)
			qry += fmt.Sprintf("  token = $%d", len(args))
		case UserField_Secret:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Secret)
			qry += fmt.Sprintf("  secret = $%d", len(args))
		case UserField_Roles:
		case UserField_CreatedBy:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.CreatedBy.ID)
			qry += fmt.Sprintf("  created_by = $%d", len(args))
		case UserField_CreatedAt:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.CreatedAt)
			qry += fmt.Sprintf("  created_at = $%d", len(args))
		case UserField_UpdatedBy:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.UpdatedBy.ID)
			qry += fmt.Sprintf("  updated_by = $%d", len(args))
		case UserField_UpdatedAt:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.UpdatedAt)
			qry += fmt.Sprintf("  updated_at = $%d", len(args))
		default:
			return fmt.Errorf("field %v is unknown", f)
		}
	}
	qry += "\nWHERE\n"
	args = append(args, obj.ID)
	qry += fmt.Sprintf("  id = $%d", len(args))
	args = append(args, obj.Version)
	qry += fmt.Sprintf(" AND\n  version = $%d", len(args))
	slog.Debug("store.User.Update", logQueryArgs(qry, args, nil)...)
	res, err := tx.ExecContext(ctx, qry, args...)
	if err != nil {
		nargs := append(append([]any{}, "qry", qry), args...)
		return updatePostgresError(r.db, "store.User.Update", err, nargs...)
	}
	ra, err := res.RowsAffected()
	if err != nil {
		nargs := append(append([]any{}, "qry", qry), args...)
		return updatePostgresError(r.db, "store.User.Update.RowsAffected", err, nargs...)
	}
	if ra == 0 {
		return fmt.Errorf("NO_ROWS_AFFECTED")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	args = []any{}
	qry = `SELECT  app_role FROM app_user_role WHERE`
	args = append(args, obj.ID)
	qry += fmt.Sprintf(" app_user = $%d", len(args))
	slog.Debug("store.User.Update.Roles.Find", logQueryArgs(qry, args, nil)...)
	rows, err := tx.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Warn("store.User.Update.Roles.Find", logQueryArgs(qry, args, err)...)
		return err
	}
	defer rows.Close()
	add_Roles := []*Role{}
	del_Roles := []*Role{}
	cur_Roles := []*Role{}
	for rows.Next() {
		var mobj Role
		err = rows.Scan(
			&mobj.ID,
		)
		if err != nil {
			slog.Warn("store.User.Update.Roles.Find.Scan", logQueryArgs(qry, args, err)...)
			return err
		}
		cur_Roles = append(cur_Roles, &mobj)
	}
	for _, mobj := range obj.Roles {
		found := false
		for _, objRef := range cur_Roles {
			if objRef.ID == mobj.ID && true {
				found = true
				break
			}
		}
		if !found {
			add_Roles = append(add_Roles, &mobj)
		}
	}
	for _, mobj := range cur_Roles {
		found := false
		for _, objRef := range obj.Roles {
			if objRef.ID == mobj.ID && true {
				found = true
				break
			}
		}
		if !found {
			del_Roles = append(del_Roles, mobj)
		}
	}
	for _, mobj := range del_Roles {
		args = []any{}
		qry = `DELETE FROM app_user_role WHERE`
		args = append(args, obj.ID)
		qry += fmt.Sprintf(" app_user = $%d", len(args))
		args = append(args, mobj.ID)
		qry += fmt.Sprintf(" AND app_role = $%d", len(args))
		slog.Debug("store.User.Update.Roles.Delete", logQueryArgs(qry, args, nil)...)
		res, err := tx.ExecContext(ctx, qry, args...)
		if err != nil {
			return updatePostgresDeleteError(r.db, "store.User.Update.Roles.Delete",
				err, logQueryArgs(qry, args, nil)...)
		}
		ra, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if ra != 1 {
			return fmt.Errorf("ERR_DELETE_FAILED")
		}
	}
	for _, mobj := range add_Roles {
		args = []any{}
		qry = `INSERT INTO app_user_role (app_user, app_role)
      VALUES (
          $1, 
          $2)`
		args = append(args, obj.ID)
		args = append(args, mobj.ID)
		slog.Debug("store.User.Update.Roles.Insert", logQueryArgs(qry, args, nil)...)
		res, err := tx.ExecContext(ctx, qry, args...)
		if err != nil {
			return updatePostgresInsertError(r.db, "store.User.Update.Roles.Insert",
				err, logQueryArgs(qry, args, nil)...)
		}
		ra, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if ra != 1 {
			return fmt.Errorf("ERR_INSERT_FAILED")
		}
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}
func (r *UserStoreImpl) UpdatePassword(ctx context.Context, id int64, version int64, value string) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	defer tx.Rollback()
	args := []any{}
	password, err := util.HashPassword(jsql.SecretValue(value))
	if err != nil {
		return err
	}
	qry := `UPDATE app_user SET `
	if len(args) > 0 {
		qry += ", "
	}
	args = append(args, password)
	qry += fmt.Sprintf("password = $%d", len(args))
	qry += ` WHERE `
	args = append(args, id)
	qry += fmt.Sprintf("  id = $%d", len(args))
	args = append(args, version)
	qry += fmt.Sprintf(" AND\n  version = $%d", len(args))
	slog.Debug("store.User.UpdatePassword", logQueryArgs(qry, args, nil)...)
	res, err := tx.ExecContext(ctx, qry, args...)
	if err != nil {
		nargs := append(append([]any{}, "qry", qry), args...)
		return updatePostgresError(r.db, "store.User.UpdatePassword", err, nargs)
	}
	ra, err := res.RowsAffected()
	if err != nil {
		slog.Warn("store.User.UpdatePassword.RowsAffected", logQueryArgs(qry, args, err)...)
		return err
	}
	if ra == 0 {
		return fmt.Errorf("NO_ROWS_AFFECTED")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}
