// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-11-03T03:51:54Z

package model

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
)

func (r *UserStoreImpl) FindOne(ctx context.Context, filter []UserFilter, sorting []UserSorting) (*User, error) {
	var err error
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		ff, ok := r.findFilters[f.Field]
		if !ok {
			return nil, fmt.Errorf("field %v is not filterable", f.Field)
		}
		qfilter, args, err = ff(qfilter, args, f.Op, f.Value)
		if err != nil {
			slog.Error("Filter", "field", f.Field, "op", f.Op, "value", string(f.Value), "Error", err)
			return nil, err
		}
	}
	qry := `
    SELECT
      ` + r.qrySelectObj() + `
    FROM
      ` + r.qryFromObj()
	if len(qfilter) > 0 {
		qry += "\n    WHERE " + strings.Join(qfilter, " AND\n      ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			ff, ok := r.fields[f.Field]
			if !ok {
				return nil, fmt.Errorf("field %v is unsortable", f.Field)
			}
			switch f.Dir {
			case SortDir_ASC:
				sorts = append(sorts, fmt.Sprintf("obj.%s ASC", ff))
			case SortDir_DESC:
				sorts = append(sorts, fmt.Sprintf("obj.%s DESC", ff))
			default:
				return nil, fmt.Errorf("invalid sort direction %v", f.Dir)
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += "\n  LIMIT 1"
	slog.Debug("store.User.FindOne", logQueryArgs(qry, args, nil)...)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Warn("store.User.FindOne", logQueryArgs(qry, args, err)...)
		return nil, err
	}
	defer rows.Close()
	if rows.Next() {
		var obj User
		err = r.scanObj(&obj, rows)
		if err != nil {
			slog.Warn("store.User.FindOne.Scan", logQueryArgs(qry, args, err)...)
			return nil, err
		}
		return &obj, nil
	}
	return nil, fmt.Errorf("not found")
}

func (r *UserStoreImpl) Find(ctx context.Context, filter []UserFilter, sorting []UserSorting, limit int, offset int64) ([]User, int64, error) {
	var err error
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		ff, ok := r.findFilters[f.Field]
		if !ok {
			return nil, 0, fmt.Errorf("field %v is not filterable", f.Field)
		}
		qfilter, args, err = ff(qfilter, args, f.Op, f.Value)
		if err != nil {
			slog.Error("Filter", "field", f.Field, "op", f.Op, "value", string(f.Value), "Error", err)
			return nil, 0, err
		}
	}
	qry := `SELECT ` + r.qrySelectCountObj() + ` FROM ` + r.qryFromObj()
	if len(qfilter) > 0 {
		qry += " WHERE " + strings.Join(qfilter, " AND ")
	}
	slog.Debug("store.User.FindCount", logQueryArgs(qry, args, nil)...)
	total := int64(0)
	err = r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
	if err != nil {
		slog.Error("Query count", "qry", qry, "Error", err)
		return nil, 0, err
	}
	qry = `
    SELECT
      ` + r.qrySelectObj() + `
    FROM
      ` + r.qryFromObj()
	if len(qfilter) > 0 {
		qry += "\n    WHERE " + strings.Join(qfilter, " AND\n      ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			ff, ok := r.fields[f.Field]
			if !ok {
				return nil, 0, fmt.Errorf("field %v is unsortable", f.Field)
			}
			switch f.Dir {
			case SortDir_ASC:
				sorts = append(sorts, fmt.Sprintf("obj.%s ASC", ff))
			case SortDir_DESC:
				sorts = append(sorts, fmt.Sprintf("obj.%s DESC", ff))
			default:
				return nil, 0, fmt.Errorf("invalid sort direction %v", f.Dir)
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	slog.Debug("store.User.Find", logQueryArgs(qry, args, nil)...)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Warn("store.User.Find", logQueryArgs(qry, args, err)...)
		return nil, 0, err
	}
	defer rows.Close()
	list := []User{}
	for rows.Next() {
		var obj User
		err = r.scanObj(&obj, rows)
		if err != nil {
			slog.Warn("store.User.Find.Scan", logQueryArgs(qry, args, err)...)
			return nil, total, err
		}
		list = append(list, obj)
	}
	return list, total, nil
}
