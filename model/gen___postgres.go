// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-11-03T03:51:54Z

package model

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"regexp"
	"strings"
	"time"
)

var postgresDuplicate = regexp.MustCompile(`duplicate key value violates unique constraint "([a-zA-Z0-9_]+)"`)

func duplicatePostgresConstraintError(db *sql.DB, err error) *ErrorDuplicate {
	if res := postgresDuplicate.FindStringSubmatch(err.Error()); res != nil {
		if len(res) == 2 {
			edup := &ErrorDuplicate{
				Constraint: res[1],
				Msg:        err.Error(),
			}
			rows, err := db.Query(`
    		SELECT
    		    rel.relname AS table_name,
    		    att.attname AS column_name
    		FROM pg_constraint con
    		JOIN pg_class rel ON rel.oid = con.conrelid
    		JOIN pg_attribute att ON att.attrelid = rel.oid AND att.attnum = ANY(con.conkey)
    		WHERE con.conname = $1`, edup.Constraint)
			if err != nil {
				slog.Error("Error querying duplicate constraint columns", "constraint", edup.Constraint, "err", err)
				return nil
			}
			defer func() {
				_ = rows.Close()
			}()
			edup.Cols = []string{}
			if rows.Next() {
				var colName string
				err = rows.Scan(&edup.Table, &colName)
				if err != nil {
					slog.Error("Error scanning duplicate constraint column", "constraint", edup.Constraint, "err", err)
					return nil
				}
				edup.Cols = append(edup.Cols, colName)
			} else {
				slog.Error("No columns found for duplicate constraint", "constraint", edup.Constraint)
			}
			return edup
		}
	}
	return nil
}

func insertPostgresError(db *sql.DB, msg string, err error, args ...any) error {
	if edup := duplicatePostgresConstraintError(db, err); edup != nil {
		return edup
	}
	nargs := append(args, slog.Any("Error", err))
	slog.Error(msg, nargs...)
	return err
}

func updatePostgresError(db *sql.DB, msg string, err error, args ...any) error {
	if edup := duplicatePostgresConstraintError(db, err); edup != nil {
		return edup
	}
	nargs := append(args, slog.Any("Error", err))
	slog.Error(msg, nargs...)
	return err
}

func updatePostgresInsertError(db *sql.DB, msg string, err error, args ...any) error {
	nargs := append(args, slog.Any("Error", err))
	slog.Error(msg, nargs...)
	return err
}

func updatePostgresDeleteError(db *sql.DB, msg string, err error, args ...any) error {
	nargs := append(args, slog.Any("Error", err))
	slog.Error(msg, nargs...)
	return err
}

func deletePostgresError(db *sql.DB, msg string, err error, args ...any) error {
	nargs := append(args, slog.Any("Error", err))
	slog.Error(msg, nargs...)
	return err
}

func filterPostgresText(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Like:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s LIKE $%d", field, len(args)))
	case FilterOp_ILike:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s ILIKE $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}

func filterPostgresTextUpper(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		val = strings.ToUpper(val)
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Like:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		val = strings.ToUpper(val)
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s LIKE $%d", field, len(args)))
	case FilterOp_ILike:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s ILIKE $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}

func filterPostgresTextLower(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		val = strings.ToLower(val)
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Like:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		val = strings.ToLower(val)
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s LIKE $%d", field, len(args)))
	case FilterOp_ILike:
		var val string
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s ILIKE $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}

func filterPostgresNumeric(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Greater:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s > $%d", field, len(args)))
	case FilterOp_GreaterEq:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s >= $%d", field, len(args)))
	case FilterOp_LessEq:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s <= $%d", field, len(args)))
	case FilterOp_Less:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s < $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}

func filterPostgresInt(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val int64
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Greater:
		var val int64
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s > $%d", field, len(args)))
	case FilterOp_GreaterEq:
		var val int64
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s >= $%d", field, len(args)))
	case FilterOp_LessEq:
		var val int64
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s <= $%d", field, len(args)))
	case FilterOp_Less:
		var val int64
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s < $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}

func filterPostgresTime(qfilter []string, args []any, field string, op FilterOp, value json.RawMessage) ([]string, []any, error) {
	switch op {
	case FilterOp_EQ:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s = $%d", field, len(args)))
	case FilterOp_Greater:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s > $%d", field, len(args)))
	case FilterOp_GreaterEq:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s >= $%d", field, len(args)))
	case FilterOp_LessEq:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s <= $%d", field, len(args)))
	case FilterOp_Less:
		var val time.Time
		err := json.Unmarshal(value, &val)
		if err != nil {
			return qfilter, args, err
		}
		args = append(args, val)
		qfilter = append(qfilter, fmt.Sprintf("%s < $%d", field, len(args)))
	default:
		return qfilter, args, fmt.Errorf("unsupported filter op %v for field %v", op, field)
	}
	return qfilter, args, nil
}
