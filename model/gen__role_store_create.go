// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-11-03T03:51:54Z

package model

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
)

func (r *RoleStoreImpl) Create(ctx context.Context, obj Role) (*Role, error) {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	txNew = true
	defer tx.Rollback()
	qry := `
    INSERT INTO app_role (
      name,
      description,
      privileges,
      modified_by,
      modified_date
    ) VALUES ($1, $2, $3, $4, $5) RETURNING id`
	slog.Debug("store.Role.Create",
		slog.String("qry", qry),
		slog.String("name", obj.Name),
		logNullString("description", obj.Description),
		slog.String("privileges", obj.Privileges),
		slog.String("modified_by", obj.UpdatedBy),
		slog.Time("modified_date", obj.UpdatedAt),
	)
	rows, err := tx.QueryContext(ctx, qry,
		obj.Name,
		obj.Description,
		obj.Privileges,
		obj.UpdatedBy,
		obj.UpdatedAt,
	)
	if err != nil {
		return nil, insertPostgresError(r.db, "store.Role.Create", err,
			slog.String("qry", qry),
			slog.String("name", obj.Name),
			logNullString("description", obj.Description),
			slog.String("privileges", obj.Privileges),
			slog.String("modified_by", obj.UpdatedBy),
			slog.Time("modified_date", obj.UpdatedAt),
		)
	}
	defer func() {
		_ = rows.Close()
	}()
	if rows.Next() {
		err = rows.Scan(&obj.ID)
		if err != nil {
			return nil, err
		}
	} else {
		slog.Error("store.ID.Create.RowsAffected",
			slog.String("qry", qry),
			slog.String("name", obj.Name),
			logNullString("description", obj.Description),
			slog.String("privileges", obj.Privileges),
			slog.String("modified_by", obj.UpdatedBy),
			slog.Time("modified_date", obj.UpdatedAt),
			slog.Any("Error", err),
		)
		return nil, fmt.Errorf("ERR_INSERT_FAILED")
	}
	rows.Close()
	if txNew {
		err = tx.Commit()
		if err != nil {
			return nil, err
		}
	}
	return &obj, nil
}
