// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-11-03T03:51:54Z

package model

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"strings"

	"example.com/app-api/util"
	"example.com/app-api/util/jsql"
)

func (r *UserStoreImpl) Create(ctx context.Context, obj User) (*User, error) {
	var tx *sql.Tx
	var err error
	var txNew bool
	obj.Email = strings.ToLower(obj.Email)
	tx, err = r.db.BeginTx(ctx, nil)
	txNew = true
	defer tx.Rollback()
	obj.Version = 1
	obj_Password, err := util.HashPassword(obj.Password)
	if err != nil {
		return nil, err
	}
	var objCreatedBy_ID jsql.NullInt64
	if obj.CreatedBy != nil {
		objCreatedBy_ID = jsql.NullInt64Value(obj.CreatedBy.ID)
	} else {
		objCreatedBy_ID = jsql.NullInt64ValueNull()
	}
	var objUpdatedBy_ID jsql.NullInt64
	if obj.UpdatedBy != nil {
		objUpdatedBy_ID = jsql.NullInt64Value(obj.UpdatedBy.ID)
	} else {
		objUpdatedBy_ID = jsql.NullInt64ValueNull()
	}
	qry := `
    INSERT INTO app_user (
      email,
      version,
      name,
      password,
      token,
      secret,
      created_by,
      created_at,
      updated_by,
      updated_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id`
	slog.Debug("store.User.Create",
		slog.String("qry", qry),
		slog.String("email", obj.Email),
		slog.Int64("version", obj.Version),
		slog.String("name", obj.Name),
		logNullSecret("password", obj.Password),
		logNullSecret("token", obj.Token),
		logNullSecret("secret", obj.Secret),
		logNullInt64("CreatedBy.id", objCreatedBy_ID),
		slog.Time("created_at", obj.CreatedAt),
		logNullInt64("UpdatedBy.id", objUpdatedBy_ID),
		slog.Time("updated_at", obj.UpdatedAt),
	)
	rows, err := tx.QueryContext(ctx, qry,
		obj.Email,
		obj.Version,
		obj.Name,
		obj_Password,
		obj.Token,
		obj.Secret,
		objCreatedBy_ID,
		obj.CreatedAt,
		objUpdatedBy_ID,
		obj.UpdatedAt,
	)
	if err != nil {
		return nil, insertPostgresError(r.db, "store.User.Create", err,
			slog.String("qry", qry),
			slog.String("email", obj.Email),
			slog.Int64("version", obj.Version),
			slog.String("name", obj.Name),
			logNullSecret("password", obj.Password),
			logNullSecret("token", obj.Token),
			logNullSecret("secret", obj.Secret),
			logNullInt64("CreatedBy.id", objCreatedBy_ID),
			slog.Time("created_at", obj.CreatedAt),
			logNullInt64("UpdatedBy.id", objUpdatedBy_ID),
			slog.Time("updated_at", obj.UpdatedAt),
		)
	}
	defer func() {
		_ = rows.Close()
	}()
	if rows.Next() {
		err = rows.Scan(&obj.ID)
		if err != nil {
			return nil, err
		}
	} else {
		slog.Error("store.ID.Create.RowsAffected",
			slog.String("qry", qry),
			slog.String("email", obj.Email),
			slog.Int64("version", obj.Version),
			slog.String("name", obj.Name),
			logNullSecret("password", obj.Password),
			logNullSecret("token", obj.Token),
			logNullSecret("secret", obj.Secret),
			logNullInt64("CreatedBy.id", objCreatedBy_ID),
			slog.Time("created_at", obj.CreatedAt),
			logNullInt64("UpdatedBy.id", objUpdatedBy_ID),
			slog.Time("updated_at", obj.UpdatedAt),
			slog.Any("Error", err),
		)
		return nil, fmt.Errorf("ERR_INSERT_FAILED")
	}
	rows.Close()
	qry = `
    INSERT INTO app_user_role (app_user, app_role)
    VALUES ($1, $2)`
	for _, objRef := range obj.Roles {
		slog.Debug("store.User.Roles.Create",
			slog.String("qry", qry),
			slog.Any("User.ID", obj.ID),
			slog.Any("Role.ID", objRef.ID),
		)
		res, err := tx.ExecContext(ctx, qry, obj.ID, objRef.ID)
		if err != nil {
			return nil, insertPostgresError(r.db, "store.User.Roles.Create", err,
				slog.String("qry", qry),
				slog.Any("User.ID", obj.ID),
				slog.Any("Role.ID", objRef.ID),
			)
		}
		ra, err := res.RowsAffected()
		if err != nil {
			slog.Error("store.User.Roles.Create.RowsAffected",
				slog.String("qry", qry),
				slog.Any("User.ID", obj.ID),
				slog.Any("Role.ID", objRef.ID),
				slog.Any("Error", err),
			)
			return nil, err
		}
		if ra != 1 {
			return nil, fmt.Errorf("ERR_INSERT_FAILED")
		}
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return nil, err
		}
	}
	return &obj, nil
}
